import {Component, ViewChild, ElementRef, OnInit, OnDestroy} from '@angular/core';
import {FormControl, FormGroup, FormsModule, ReactiveFormsModule, Validators} from '@angular/forms';
import {MatFormFieldModule} from '@angular/material/form-field';
import {MatInputModule} from '@angular/material/input';
import {ModalComponent} from '../modal/modal.component';
import {SharedFilesService} from '../../services/shared-files.service';
import {Subscription, forkJoin, firstValueFrom} from 'rxjs';
import {FilesManagerService} from '../../services/files-manager.service';
import {OllamaService} from '../../services/ollama.service';
import {MarkdownEditorComponent} from '../markdown-editor/markdown-editor.component';
import {ErrorModalComponent} from '../error-modal/error-modal.component';

/**
 * The TextComponent is responsible for displaying and editing the content of a file.
 * It includes a markdown editor, AI text generation capabilities, and auto-saving.
 */
@Component({
  selector: 'app-text-page',
  imports: [
    MatFormFieldModule,
    MatInputModule,
    FormsModule,
    ReactiveFormsModule,
    ModalComponent,
    MarkdownEditorComponent,
    ErrorModalComponent
  ],
  templateUrl: './text-component.component.html',
  styleUrl: './text-component.component.css'
})
export class TextComponent implements OnInit, OnDestroy {

    // --- Component State ---

    /** Whether the modal for adding generated text is visible. */
    isModalVisibleAdd = false;

    /** The title for the text generation modal. */
    title = "What should I generate?";

    /** The main content of the file being edited. */
    text: string = "";

    /** The text generated by the AI, pending user validation. */
    generatedText: string = "";

    /** The name of the currently loaded file. */
    fileName = "";

    /** The ID of the currently loaded file. */
    currentFileID: number = 0;

    /** Whether the component is waiting for the user to accept or reject generated text. */
    pendingValidation: boolean = false;

    /** Whether the error modal is visible. */
    errorVisible = false;

    /** The message to display in the error modal. */
    errorMessage = 'An unexpected error occurred';

    /** Reference to the prompt textarea element. */
    @ViewChild('prompt') promptTextarea!: ElementRef<HTMLTextAreaElement>;

    /** Form group for the main text area. */
    textForm: FormGroup = new FormGroup({
        text: new FormControl(this.text, Validators.required)
    });

    // --- Private Properties ---

    /** The subscription to the shared file service. */
    private subscription: Subscription = new Subscription();

    /** The timer for the auto-save functionality. */
    private autoSaveTimer?: number;

    /** Flag to indicate if the component has been destroyed. */
    private isDestroyed = false;

    /**
     * Initializes the component and injects required services.
     * @param shareFiles Service for sharing file selection events.
     * @param filesManager Service for file-related API calls.
     * @param ollamaService Service for AI text generation.
     */
    constructor(
        private shareFiles: SharedFilesService,
        private filesManager: FilesManagerService,
        private ollamaService: OllamaService
    ) {}

    /**
     * Lifecycle hook that runs when the component is initialized.
     * Subscribes to file selection changes and starts the auto-save timer.
     */
    ngOnInit() {
        this.subscription = this.shareFiles.selectedFile$.subscribe(file => {
            if (this.isDestroyed) {
                return;
            }

            // Stop any existing timer when selection changes
            if (this.autoSaveTimer) {
                window.clearInterval(this.autoSaveTimer);
                this.autoSaveTimer = undefined;
            }

            if (file) {
                this.currentFileID = file;
                this.updateText(this.currentFileID);
                this.startAutoSave(); // Start auto-save when a file is loaded
            } else {
                // If file is null, clear the editor state
                this.currentFileID = 0;
                this.fileName = "";
                this.text = "";
            }
        });
    }

    /**
     * Starts the auto-save timer, which periodically saves the file content.
     */
    private startAutoSave() {
        // Save every 5 seconds
        this.autoSaveTimer = window.setInterval(() => {
            if (!this.isDestroyed) {
                this.save().catch(error => {
                    console.error('Auto-save failed:', error);
                    this.showErrorModal('Auto-save failed');
                });
            }
        }, 5000);
    }

    /**
     * Fetches the name and content of a file and updates the component's state.
     * @param currentFile The ID of the file to load.
     */
    updateText(currentFile: number) {
        const userToken = localStorage.getItem("token");
        if (userToken) {
            forkJoin({
                info: this.filesManager.getFileInfo(currentFile, userToken),
                content: this.filesManager.getFileContent(currentFile, userToken)
            }).subscribe({
                next: ({info, content}) => {
                    if (!this.isDestroyed) {
                        this.fileName = info.name;
                        this.text = content;
                    }
                },
                error: (error) => {
                    console.error('Error loading file:', error);
                    this.showErrorModal('Failed to load the file');
                }
            });
        }
    }

    /**
     * Handles the content change event from the markdown editor.
     * @param newContent The new content from the editor.
     */
    onContentChange(newContent: string) {
        this.text = newContent;

        // Optional: Reset the auto-save timer on each modification
        if (this.autoSaveTimer) {
            window.clearInterval(this.autoSaveTimer);
            this.startAutoSave();
        }
    }

    /**
     * Saves the current file content to the database.
     * Returns a promise that resolves when the save is complete.
     */
    async save(): Promise<void> {
        const userToken = localStorage.getItem("token");
        if (userToken && this.currentFileID !== 0) {
            try {
                await firstValueFrom(this.filesManager.updateFileContent(
                    this.currentFileID,
                    userToken,
                    this.text
                ));
            } catch (error) {
                console.error('Error saving file:', error);
                this.showErrorModal('Failed to save the file');
            }
        }
    }

    /**
     * Shows the modal for AI text generation.
     */
    showModalAdd() {
        this.isModalVisibleAdd = true;
    }

    /**
     * Hides the modal for AI text generation.
     */
    hideModal() {
        this.isModalVisibleAdd = false;
    }

    /**
     * Shows the error modal with a specified message.
     * @param message The message to display. If not provided, a default message is used.
     */
    showErrorModal(message?: string) {
        this.errorMessage = message ?? 'An unexpected error occurred';
        this.errorVisible = true;
    }

    /**
     * Lifecycle hook that runs when the component is destroyed.
     * Cleans up subscriptions and timers, and performs a final save.
     */
    ngOnDestroy(): void {
        this.isDestroyed = true;

        if (this.subscription) {
            this.subscription.unsubscribe();
        }

        if (this.autoSaveTimer) {
            window.clearInterval(this.autoSaveTimer);
            this.autoSaveTimer = undefined;
        }

        // Perform a final save before exiting
        this.save().catch(error => {
            console.error('Final save failed:', error);
            this.showErrorModal('Failed to save the file');
        });
    }

    /**
     * Handles the submission of the AI text generation modal.
     * Sends the user's prompt and context to the AI service.
     * @param data An object containing the `name` (prompt) and `context`.
     */
    async handleModalAddSubmit(data: { name: string, context: string }) {
        if (!this.text) {
            console.error("Text is empty");
            return;
        }

        if (!data.name || data.name.trim() === "") {
            console.error("Prompt is empty");
            return;
        }

        const tokenUser = localStorage.getItem('token');
        if (!tokenUser) {
            console.error("No authentication token found");
            return;
        }

        try {
            // Get context from the current directory
            const getContext = await this.filesManager.getDirContent(
                this.currentFileID,
                tokenUser
            ).toPromise();

            if (!getContext) {
                console.error("Failed to get context");
                this.showErrorModal('Failed to get context');
                return;
            }

            const context = JSON.parse(getContext);

            // Call the Ollama service
            const result = await this.ollamaService.addButtonOllama(
                this.currentFileID,
                tokenUser,
                data.name,
                context,
                this.text
            );

            if (result) {
                const res = JSON.parse(result);
                if (res.param?.response && res.param.response.length > 0) {
                    const rawText = res.param.response;
                    if (rawText !== '') {
                        this.generatedText = rawText;
                        this.pendingValidation = true;
                    } else {
                        console.warn("Answer is empty after processing.");
                    }
                }
            }
        } catch (error) {
            console.error("Error generating text with Ollama:", error);
            this.showErrorModal('Error generating text with Ollama');
        }
    }

    /**
     * Appends the AI-generated text to the current text and saves the file.
     */
    applyGeneratedText() {
        this.text += this.generatedText;
        this.generatedText = '';
        this.pendingValidation = false;

        // Automatically save after applying the new text
        this.save().catch(error => {
            console.error('Error saving after applying generated text:', error);
            this.showErrorModal('Error saving after applying generated text');
        });
    }

    /**
     * Discards the AI-generated text and resets the validation state.
     */
    rejectGeneratedText() {
        this.generatedText = '';
        this.pendingValidation = false;
    }
}